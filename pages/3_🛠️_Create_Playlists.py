"""
3_ðŸ› ï¸_Create_Playlists.py â€“ Classifica AI e Crea Playlist su Spotify
"""
import streamlit as st
import pandas as pd
import json
import os
import sys

# Aggiungi root al path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from sidebar import render_sidebar

from spotify_client import (
    get_or_create_playlist,
    add_tracks_to_playlist,
    get_auth_manager,
    get_spotify_client,
    get_all_user_playlists
)
from gemini_classifier import classify_all_tracks
from classifier import (
    build_year_buckets,
    build_genre_buckets,
    YEAR_PLAYLISTS,
    GENRE_PLAYLISTS,
)
from spotipy.exceptions import SpotifyException

st.set_page_config(page_title="Create Playlists", page_icon="ðŸ› ï¸", layout="wide")

render_sidebar()

if "sp" not in st.session_state:
    st.warning("âš ï¸ Non sei autenticato. Torna alla Home page per fare il login.")
    st.stop()
    
sp = st.session_state["sp"]
if "user" not in st.session_state:
    st.session_state["user"] = sp.current_user()
    
user_id = st.session_state["user"]["id"]
tracks = st.session_state.get("tracks", [])

if not tracks:
    st.warning("âš ï¸ Nessuna traccia da processare. Torna alla Home.")
    st.stop()


# â”€â”€ LOGIC FUNCTIONS â”€â”€

def _save_created_history(new_entries):
    """Salva storico su file."""
    try:
        hist_file = f"user_data/history_{user_id}.json"
        existing = []
        if os.path.exists(hist_file):
            with open(hist_file, "r", encoding="utf-8") as f:
                existing = json.load(f)
        
        existing_map = {item["Playlist"]: item for item in existing}
        for entry in new_entries:
            existing_map[entry["Playlist"]] = entry
        
        final_list = list(existing_map.values())
        with open(hist_file, "w", encoding="utf-8") as f:
            json.dump(final_list, f, indent=2)
    except Exception as e:
        print(f"Error saving history: {e}")

def create_playlists_action(target_buckets, user_choices):
    """
    Esegue la creazione/aggiornamento su Spotify.
    user_choices: dict { "Nome Categoria": "ID_PLAYLIST" oppure "NEW" }
    """
    sp = st.session_state["sp"]
    
    st.info("Inizio operazione...")
    progress_bar = st.progress(0, text="Avvio...")
    total = len(target_buckets)
    
    # Recupera metadati playlist esistenti per avere i nomi corretti in caso di update
    playlists_map_id_to_name = {}
    
    try:
        user_pls = get_all_user_playlists(sp)
        playlists_map_id_to_name = {p["id"]: p["name"] for p in user_pls}
    except Exception as e:
        print(f"Warning: Could not fetch playlists in action: {e}")
    
    created_now = []

    try:
        updated_count = 0
        for idx, (cat_name, track_list) in enumerate(target_buckets.items(), 1):
             if not track_list: continue

             # Recupera la scelta dell'utente passata dalla UI
             choice_id = user_choices.get(cat_name, "NEW")
             
             playlist_id = None
             action_type = ""
             target_name_display = cat_name

             if choice_id == "NEW":
                 # CREA NUOVA
                 progress_bar.progress(idx / total, text=f"Creating new: {cat_name}...")
                 # Passiamo la cache per evitare chiamate API inutili in lettura
                 playlist_id = get_or_create_playlist(
                    sp, user_id, cat_name, 
                    description=f"Auto-generated by AlgoRhythm ðŸŽµ ({len(track_list)} tracks)"
                 )
                 action_type = "Created"
             else:
                 # AGGIUNGI A ESISTENTE
                 playlist_id = choice_id
                 target_name_display = playlists_map_id_to_name.get(playlist_id, cat_name)
                 
                 progress_bar.progress(idx / total, text=f"Updating: {target_name_display}...")
                 action_type = "Updated"
            
             # Aggiungi Tracce
             uris = [t["track_id"] for t in track_list]
             add_tracks_to_playlist(sp, playlist_id, uris)
             
             created_now.append({"Playlist": target_name_display, "Action": action_type, "Tracks": len(uris)})
             updated_count += 1

        st.success(f"âœ… Operazione completata! {updated_count} playlist processate.")
        st.balloons()
        
        _save_created_history(created_now)
        if "created_info" not in st.session_state: st.session_state["created_info"] = []
        st.session_state["created_info"] = st.session_state["created_info"] + created_now
        
    except Exception as e:
        st.error(f"Errore durante l'operazione: {e}")
        # Loggare l'errore completo in console Ã¨ utile per debug
        print(f"Error in create_playlists_action: {e}")


# â”€â”€ UI â”€â”€

st.title("ðŸ› ï¸ Laboratorio Playlist")

tab1, tab2 = st.tabs(["1. Classificazione AI", "2. Creazione Su Spotify"])

# TAB 1: CLASSIFICAZIONE
with tab1:
    st.markdown("### ðŸ¤– Analisi AI dei Generi")
    st.write("Usa Gemini per analizzare il mood di ogni brano.")
    
    if st.button("â–¶ï¸ Avvia Analisi AI"):
        st.info("Avvio processo classificazione...")
        
        container = st.container()
        progress = st.progress(0)
        
        # Generator
        gen = classify_all_tracks(tracks)
        current_class = st.session_state.get("classifications", {})

        try:
            for b_num, total_b, b_res in gen:
                pct = b_num / total_b if total_b else 0
                progress.progress(pct, text=f"Batch {b_num}/{total_b}")
                
                # Update partial results
                current_class.update(b_res)
                st.session_state["classifications"] = current_class
                
                # Show sample
                with container:
                    # Show last 3 classified
                    items = list(b_res.items())[-3:]
                    txt = " | ".join([f"{k}: {v}" for k,v in items])
                    st.caption(f"Last batch: {txt}")

        except Exception as e:
            st.error(f"Errore AI: {e}")
            
        st.success("Analisi completata!")
        
        # Build buckets immediately
        st.session_state["genre_buckets"] = build_genre_buckets(tracks, current_class)


# TAB 2: CREAZIONE
with tab2:
    st.markdown("### ðŸš€ Genera Playlist")
    
    # Check if we have buckets
    year_buckets = st.session_state.get("year_buckets", {})
    if not year_buckets:
        st.session_state["year_buckets"] = build_year_buckets(tracks)
        year_buckets = st.session_state["year_buckets"]
        
    genre_buckets = st.session_state.get("genre_buckets", {})
    

    # Per ogni bucket, permetti all'utente di scegliere: "Crea Nuova" o "Aggiungi a Esistente"
    # Recuperiamo le playlist esistenti dell'utente per il dropdown
    # (Lo cacheiamo in session state per non richiamare API ogni volta)
    
    try:
        with st.spinner("Caricamento playlist utente..."):
            user_pls = get_all_user_playlists(st.session_state["sp"])
            existing_playlists_map = {p["name"]: p["id"] for p in user_pls}
    except Exception:
        existing_playlists_map = {}

    
    # Opzioni dropdown: chiave visualizzata -> valore ID
    # Creiamo una lista di nomi per la UI
    existing_names = ["(Crea Nuova Playlist)"] + sorted(list(existing_playlists_map.keys()))

    # Helper function per renderizzare UI e catturare le scelte
    def render_creation_section(title, buckets, key_prefix):
        st.subheader(title)
        if not buckets:
            st.warning("Nessun dato disponibile. Fai l'analisi o ricarica.")
            return None

        # Dizionario per salvare le scelte dell'utente: { "Nome Bucket": "ID Playlist Scelta" o "NEW" }
        user_choices_map = {}
        
        # Loop over generated buckets
        for cat_name, track_list in buckets.items():
            if not track_list: continue
            
            with st.expander(f"ðŸ“‚ **{cat_name}** ({len(track_list)} brani)", expanded=False):
                # Anteprima brani
                st.caption(", ".join([f"{t.get('artist','')} - {t.get('name','')}" for t in track_list[:5]]) + "...")
                
                # Scelta Destinazione UI
                unique_key = f"{key_prefix}_{cat_name}"
                
                # Default selection
                default_idx = 0
                
                choice = st.selectbox(
                    f"Destinazione per '{cat_name}':", 
                    options=existing_names,
                    index=default_idx,
                    key=unique_key
                )
                
                # Risolvi la scelta in ID o "NEW"
                if choice == "(Crea Nuova Playlist)":
                    val_id = "NEW"
                else:
                    val_id = existing_playlists_map.get(choice)
                
                user_choices_map[cat_name] = val_id

        return user_choices_map

    col_a, col_b = st.columns(2)
    
    with col_a:
        user_choices_decades = render_creation_section("ðŸ“… Playlist Decadi", year_buckets, "decades")
        if user_choices_decades and st.button("ðŸš€ Avvia Creazione (Decadi)", key="btn_start_decades"):
             create_playlists_action(year_buckets, user_choices_decades)

    with col_b:
        user_choices_genres = render_creation_section("ðŸŽ­ Playlist Generi AI", genre_buckets, "genres")
        # Mostra il pulsante solo se ci sono buckets
        if user_choices_genres is not None:
             if st.button("ðŸš€ Avvia Creazione (Generi)", key="btn_start_genres"):
                  create_playlists_action(genre_buckets, user_choices_genres)
        elif not genre_buckets:
             st.info("Esegui l'analisi AI nel Tab 1 per vedere i generi.")


    st.markdown("---")
    st.write("### ðŸ“œ Storico Creazioni")
    
    hist = st.session_state.get("created_info", [])
    if not hist:
        # Load from file if empty
        try:
             hist_file = f"user_data/history_{user_id}.json"
             if os.path.exists(hist_file):
                 with open(hist_file) as f:
                     hist = json.load(f)
                     st.session_state["created_info"] = hist
        except: pass

    if hist:
        # Convert to DF for clearer view
        st.dataframe(pd.DataFrame(hist), use_container_width=True)
    else:
        st.caption("Nessuna playlist creata finora.")
